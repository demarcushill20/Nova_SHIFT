# How to Add New Tools to Nova SHIFT

Based on the project documentation (`RESEARCH.md`, `PLANNING.md`, `ARCHITECTURE.md`, `task.md`), here's how you can build and add new tools to the Nova SHIFT tool registry:

**Core Concept:**

Tools in Nova SHIFT are designed as modular plugins. Each tool consists of two main parts:

1.  **Python Implementation:** The actual code that performs the tool's function.
2.  **Toolkit Definition (`toolkit.json`):** A JSON file that describes the tool (or a collection of related tools), its capabilities, how to use it (inputs/outputs), its dependencies, and how the system should load its code.

**Manual Process for Adding a New Tool:**

Based on the architecture and initial implementation phases described (especially Phase 1 tasks in `task.md`), the manual process involves these steps:

1.  **Implement the Tool's Logic (Python):**
    *   Write the Python function(s) that perform the desired action.
    *   Place this code in an appropriate module, likely within the `nova_shift/tools/` directory structure (as suggested in `ARCHITECTURE.md`, Section 7.1).
    *   Ensure the function takes the expected inputs and returns the expected outputs.
    *   Follow the project's coding standards (linting, formatting).

2.  **Define the `toolkit.json`:**
    *   Create a `toolkit.json` file for your new tool or add its definition to an existing relevant toolkit file.
    *   This JSON file **must** conform to the schema defined in the project (detailed in `ARCHITECTURE.md`, Section 5.2.1). Key fields include:
        *   `name`: Unique name for the toolkit.
        *   `version`: Semantic version.
        *   `description`: What the toolkit does.
        *   `tools`: An array, where each object describes a single tool:
            *   `name`: Unique name of the tool within the toolkit.
            *   `function`: The exact name of the Python function to call.
            *   `description`: Detailed description for the LLM agent to understand its purpose.
            *   `inputs`: List of input parameters (`"param_name:type"`).
            *   `outputs`: List of output values (`"output_name:type"`).
        *   `requirements`: (Optional) List any required Python packages or environment variables (API keys).
        *   `loading_info`: Specifies how to load the code (e.g., `"type": "python_module"`, `"path": "nova_shift.tools.my_tool.my_tool_module"`).

3.  **Register the Toolkit:**
    *   The Tool Registry component (`core/tool_registry.py` likely) is responsible for knowing about available tools.
    *   You need to ensure the registry loads your new `toolkit.json` definition upon initialization. This might involve adding the path to your JSON file to a list that the registry reads, or updating the registry's internal dictionary if it's hardcoded initially (as per Task P1.T3).

4.  **Manage Dependencies:**
    *   If your tool requires new Python packages, add them to the `requirements.txt` file.
    *   If your tool needs API keys or other secrets, ensure they are documented in `.env.example` and provided in the actual `.env` file during runtime.

5.  **Write Tests:**
    *   Create unit tests (`pytest`) for your new tool's Python function(s) to ensure correctness and maintainability (as per Task P1.T6).

**Automated Process (Future - Phase 4):**

The project plan (`task.md`, Task P4.T3) includes creating a "Developer Agent." This agent aims to automate the process:

*   It would take a natural language description of the desired tool.
*   Use an LLM to generate the Python code and the `toolkit.json`.
*   Potentially run basic tests in a sandbox.
*   Register the new tool with the Tool Registry (possibly after a manual review step initially).

**Security Considerations:**

Remember that dynamically loading and executing code (especially code potentially generated by an LLM in the future) carries security risks. The architecture plans for sandboxing tool execution (Task P5.T2), which is crucial. When adding tools manually, be mindful of the security implications of the code you write.

**Diagram: Tool Addition Workflow**

```mermaid
graph TD
    subgraph Developer Action
        direction TB
        A[1. Write Python Code for Tool Logic<br>(e.g., in nova_shift/tools/my_tool/)]
        B[2. Create toolkit.json<br>(Define metadata, function, I/O, loading path)]
        C[3. Update Tool Registry Loader<br>(Ensure registry reads the new JSON)]
        D[4. Update requirements.txt / .env.example<br>(If new dependencies/keys needed)]
        E[5. Write Unit Tests<br>(pytest for the Python code)]
    end

    subgraph System Components
        direction TB
        F[Tool Registry<br>(core/tool_registry.py)]
        G[Agent<br>(e.g., Specialist Agent)]
        H[Python Tool Code<br>(nova_shift/tools/my_tool/my_tool.py)]
        I[Toolkit Definition<br>(nova_shift/tools/my_tool/toolkit.json)]
    end

    A --> H;
    B --> I;
    C --> F;
    F -- Loads Definition --> I;
    G -- Discovers Tool via --> F;
    G -- Gets Loading Info from --> F;
    G -- Dynamically Loads & Executes --> H;

    style Developer Action fill:#lightgreen,stroke:#333,stroke-width:2px
    style System Components fill:#lightblue,stroke:#333,stroke-width:2px
```

This explanation covers the process based on the design outlined in the project documentation.